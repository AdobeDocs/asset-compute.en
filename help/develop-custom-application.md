---
title: Develop for [!DNL Asset Compute Service].
description: Create custom applications using [!DNL Asset Compute Service].
---

# Develop a custom applications {#develop}

Before you begin to develop a custom application:

* Ensure that all the [prerequisites](/help/understand-extensibility.md#prerequisites-and-provisioning) are met.
* Install the [required software tools](/help/setup-environment.md#create-dev-environment).
* See [set up your environment](setup-environment.md) to make sure you are ready to create a custom application.

## Create a custom application {#create-custom-application}

Make sure to have the [Adobe I/O CLI](https://github.com/adobe/aio-cli) installed locally.

1. To create a custom application, [create a Firefly app](https://github.com/AdobeDocs/project-firefly/blob/master/getting_started/first_app.md#4-bootstrapping-new-app-using-the-cli). To do so, execute `aio app init <app-name>` in your terminal.

    If you have not logged in already, this command prompts a browser asking you to sign into the [Adobe Developer Console](https://console.adobe.io/) with your Adobe ID. See [here](https://github.com/AdobeDocs/project-firefly/blob/master/getting_started/first_app.md#3-signing-in-from-cli) for more information on signing in from the cli.

    Adobe recommends that you login. If you are having issues then follow the instructions [to create an app without logging in](https://github.com/AdobeDocs/project-firefly/blob/master/getting_started/first_app.md#42-developer-is-not-logged-in-as-enterprise-organization-user).

1. After logging in, follow the prompts in the CLI and select the `Organization`, `Project`, and `Workspace` to use for the application. Choose the project and workspace you created when you [set up your environment](setup-environment.md).

    ```sh
    $ aio app init <app-name>
    Retrieving information from Adobe I/O Console..
    ? Select Org My Adobe Org
    ? Select Project MyFireflyProject
    ? Select Workspace myworkspace
    create console.json
    ```

1. When prompted with `Which Adobe I/O App features do you want to enable for this project?`, select at least `Actions`:

    ```bash
    ? Which Adobe I/O App features do you want to enable for this project?
    select components to include (Press <space> to select, <a> to toggle all, <i> to invert selection)
    ❯◉ Actions: Deploy Runtime actions
    ◯ Events: Publish to Adobe I/O Events
    ◯ Web Assets: Deploy hosted static assets
    ◯ CI/CD: Include GitHub Actions based workflows for Build, Test and Deploy
    ```

1. When prompted `Which type of sample actions do you want to create?`, make sure to select `Adobe Asset Compute Worker`:

    ```bash
    ? Which type of sample actions do you want to create?
    Select type of actions to generate
    ❯◉ Adobe Asset Compute Worker
    ◯ Generic
    ```

1. Follow the rest of the prompts and open the new application in Visual Studio Code (or your favorite code editor). It contains the scaffolding and sample code for a custom application.

    Read here about the [main components of a Firefly app](https://github.com/AdobeDocs/project-firefly/blob/master/getting_started/first_app.md#5-anatomy-of-a-project-firefly-application).

    The template application leverages our [Asset Compute SDK](https://github.com/adobe/asset-compute-sdk#asset-compute-sdk) for the uploading, downloading, and orchestration of application renditions so developers only need to implement the custom application logic. Inside the `actions/<worker-name>` folder, the `index.js` file is where to add the custom application code.

See [example custom applications](#try-sample) for examples and ideas for custom applications.

### Add credentials {#add-credentials}

As you log in when creating the application, most of the Firefly credentials get collected in your ENV file. However, using the developer tool requires additional credentials.

<!-- TBD: Check if manual setup of credentials is required.
Manual set up of credentials is removed from troubleshooting and best practices page. Link was broken.
If you did not log in, refer to our troubleshooting guide to [set up credentials manually](troubleshooting.md).
-->

#### Developer tool storage credentials {#developer-tool-credentials}

The developer tool used to test custom applications with the actual [!DNL Asset Compute service] requires a cloud storage container for hosting test files and for receiving and displaying renditions generated by applications.

   >[!NOTE]
   >
   >This is separate from the cloud storage of [!DNL Adobe Experience Manager] as a Cloud Service. It only applies for developing and testing with the Asset Compute developer tool.

Make sure to have access to a [supported cloud storage container](https://github.com/adobe/asset-compute-devtool#prerequisites). This container can be shared by multiple developers across different projects as needed.

#### Add credentials to ENV file {#add-credentials-env-file}

Add the following credentials for the developer tool to the ENV file in the root of your Firefly project:

1. Add the absolute path to the private key file created while adding services to your Firefly Project:

    ```conf
    ASSET_COMPUTE_PRIVATE_KEY_FILE_PATH=
    ```

1. Add either S3 or Azure Storage credentials. You only need access to one cloud storage solution.

    ```conf
    # S3 credentials
    S3_BUCKET=
    AWS_ACCESS_KEY_ID=
    AWS_SECRET_ACCESS_KEY=
    AWS_REGION=

    # Azure Storage credentials
    AZURE_STORAGE_ACCOUNT=
    AZURE_STORAGE_KEY=
    AZURE_STORAGE_CONTAINER_NAME=
    ```

## Execute the application {#run-custom-application}

Before executing the application with the Asset Compute Developer Tool, properly configure the [credentials](#developer-tool-credentials).

To run the application in the developer tool, use `aio app run` command. It deploys the action to Adobe I/O Runtime and start the development tool on your local machine. This tool is used to test application requests during development. Here is an example rendition request:

```json
"renditions": [
    {
        "worker": "https://1234_my_namespace.adobeioruntime.net/api/v1/web/example-custom-worker-master/worker",
        "name": "image.jpg"
    }
]
```

>[!NOTE]
>
>Do not use the `--local` flag with the `run` command. It does not work with [!DNL Asset Compute] custom applications and the Asset Compute Developer tool. Custom applications are called by the [!DNL Asset Compute Service] which cannot access actions running on developer's local machines.

See [here](test-custom-application.md) how to test and debug your application. When you are finished developing your custom application, [deploy your custom application](deploy-custom-application.md).

## Try the sample application provided by Adobe {#try-sample}

The following are example custom applications:

* [worker-basic](https://github.com/adobe/asset-compute-example-workers/tree/master/projects/worker-basic)
* [worker-animal-pictures](https://github.com/adobe/asset-compute-example-workers/tree/master/projects/worker-animal-pictures)

### Template custom application {#template-custom-application}

The [worker-basic](https://github.com/adobe/asset-compute-example-workers/tree/master/projects/worker-basic) is a template application. It generates a rendition by simply copying the source file. The content of this application is the template received when choosing `Adobe Asset Compute` in the creation of the aio app.

The application file, [`worker-basic.js`](https://github.com/adobe/asset-compute-example-workers/blob/master/projects/worker-basic/worker-basic.js) uses the [`asset-compute-sdk`](https://github.com/adobe/asset-compute-sdk#overview) to download the source file, orchestrate each rendition processing, and upload the resulting renditions back to cloud storage.

The [`renditionCallback`](https://github.com/adobe/asset-compute-sdk#rendition-callback-for-worker-required) defined inside the application code, is where to perform all the application processing logic. The rendition callback in `worker-basic` simply copies the source file contents to the rendition file.

```javascript
const { worker } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition) => {
    // copy source to rendition to transfer 1:1
    await fs.copyFile(source.path, rendition.path);
});
```

## Rendition post-processing {#rendition-post-processing}

[Adobe Asset Compute SDK](https://github.com/adobe/asset-compute-sdk) supports post-processing of renditions. It is based on the instructions defined in the rendition object. This post-processing is available to any custom application, as it is done using the SDK.

The supported use cases are:

* Crop a rendition to a rectangle whose limits are defined by crop.w, crop.h, crop.x and crop.y. It is defined by `instructions.crop` in the rendition object.
* Resize images using width, height, or both. It is defined by `instructions.width` and `instructions.height` in the rendition object. To resize using only width or height, set only one value. Compute Service conserves the aspect ratio.
* Set the quality for a JPEG image. It is defined by `instructions.quality` in the rendition object. The best quality is denoted by `100` and smaller values indicate reduced quality.
* Create interlaced images. It is defined by `instructions.interlace` in the rendition object.
* Set DPI to adjust the rendered size for desktop publishing purposes by adjusting the scale applied to the pixels. It is defined by `instructions.dpi` in the rendition object to change dpi resolution. However, to resize the image so that it is the same size at a different resolution, use the `convertToDpi` instructions.
* Resize the image such that its rendered width or height remains the same as the original at the specified target resolution (DPI). It is defined by `instructions.convertToDpi` in the rendition object.

## Call an external API {#call-external-api}

In the application code, you can make external API calls to help with application processing. An example application file invoking external API is below.

```javascript
exports.main = worker(async function (source, rendition) {

    const response = await fetch('https://adobe.com', {
        method: 'GET',
        Authorization: params.AUTH_KEY
    })
});
```

For example, the [`worker-animal-pictures`](https://github.com/adobe/asset-compute-example-workers/blob/master/projects/worker-animal-pictures/worker-animal-pictures.js#L46) makes a fetch request to a static URL from Wikimedia using the [`node-httptransfer`](https://github.com/adobe/node-httptransfer#node-httptransfer) library.

<!-- TBD: Revisit later to see if this note is required.
>[!NOTE]
>
>For extra authorization for these API calls, see [custom authorization checks](#custom-authorization-checks).
-->

### Pass custom parameters {#pass-custom-parameters}

You can pass custom defined parameters through the rendition objects. They can be referenced inside the application in [`rendition` instructions](https://github.com/adobe/asset-compute-sdk#rendition). An example of a rendition object is:

```json
"renditions": [
    {
        "worker": "https://1234_my_namespace.adobeioruntime.net/api/v1/web/example-custom-worker-master/worker",
        "name": "image.jpg",
        "my-custom-parameter": "my-custom-parameter-value"
    }
]
```

An example of a application file accessing custom parameter is:

```javascript
exports.main = worker(async function (source, rendition) {

    const customParam = rendition.instructions['my-custom-parameter'];
    console.log('Custom paramter:', customParam);
    // should print out `Custom parameter: "my-custom-parameter-value"`
});
```

The `example-worker-animal-pictures` passes a custom parameter [`animal`](https://github.com/adobe/asset-compute-example-workers/blob/master/projects/worker-animal-pictures/worker-animal-pictures.js#L39) to determine which file to fetch from Wikimedia.

## Authentication and authorization support {#authentication-authorization-support}

By default, Asset Compute custom applications come with Authorization and Authentication checks for Firefly Applications. This is enabled by setting the `require-adobe-auth` annotation to `true` in the `manifest.yml`.

### Access other Adobe APIs {#access-adobe-apis}

<!-- TBD: Revisit this section. Where do we document console workspace creation?
-->

Add the API services to the [!DNL Asset Compute] Console workspace created in [set up](#set-up) step 5. These services are part of the JWT access token generated by [!DNL Asset Compute Service]. The token and other credentials are accessible inside the application action `params` object.

```javascript
const accessToken = params.auth.accessToken; // JWT token for Technical Account with entitlements from the console workspace to the API service
const clientId = params.auth.clientId; // Technical Account client Id
const orgId = params.auth.orgId; // Experience Cloud Organization
```

### Pass credentials for third-party systems {#pass-credentials-for-tp}

To handle credentials for other external services, pass these as default parameters on the actions. These are automatically encrypted in transit. For more information, see [creating actions in Runtime developer guide](https://www.adobe.io/apis/experienceplatform/runtime/docs.html#!adobedocs/adobeio-runtime/master/guides/creating_actions.md). Then set them using environment variables during deployment. These parameters can be accessed in the `params` object inside the action.

Set the default parameters inside the `inputs` in the `manifest.yml`:

```yaml
packages:
  __APP_PACKAGE__:
    actions:
      worker:
        function: 'index.js'
        runtime: 'nodejs:10'
        web: true
        inputs:
           secretKey: $SECRET_KEY
        annotations:
          require-adobe-auth: true
```

The `$VAR` expression reads the value from an environment variable named `VAR`.

During development, the value can be set in the local ENV file as `aio` automatically reads environment variables from ENV files in addition to the variables set from the invoking shell. In this example, the ENV file looks like:

```CONF
#...
SECRET_KEY=secret-value
```

For production deployment one might set the environment variables in the CI system, for example using secrets in GitHub Actions. Lastly, access the default parameters inside the application as such:

```javascript
const key = params.secretKey;
```

## Sizing applications {#sizing-workers}

An application executes in a container in Adobe I/O Runtime with [limits](https://www.adobe.io/apis/experienceplatform/runtime/docs.html#!adobedocs/adobeio-runtime/master/guides/system_settings.md) that can be configured through the `manifest.yml`:

```yaml
    actions:
      myworker:
        function: /actions/myworker/index.js
        limits:
          timeout: 300000
          memorySize: 512
          concurrency: 1
```

Due to the more extensive processing typically done by Asset Compute applications, it is more likely one has to adjust these limits for optimal performance (large enough to handle binary assets) and efficiency (not wasting resources due to unused container memory).

The default timeout for actions in Runtime is a minute but it can be increased by setting the `timeout` limit (in milliseconds). If you expect to process larger files, increase this time. Consider the total time it takes to download the source, process the file and upload the rendition. If an action times out, i.e. does not return the activation before the specified timeout limit, Runtime discards the container and not reuse it.

Asset compute applications by nature tend to be network and disk IO bound. The source file has to be downloaded first, processing is often IO heavy and then resulting renditions are uploaded again.

The memory available to an action container is specified by `memorySize` in MB. Currently this also defines how much CPU access the container gets, and most importantly it is a key element of the cost of using Runtime (larger containers cost more). Use a larger value here when your processing requires more memory or CPU but be careful to not waste resources as the larger the containers are, the lower the overall throughput is.

Furthermore, it is possible to control action concurrency within a container using the `concurrency` setting. This is the number of concurrent activations a single container (of the same action) gets. In this model, the action container is like a Node.js server receiving multiple concurrent requests, up to that limit. If not set, the default in Runtime is 200, which is great for smaller Firefly actions, but usually too large for Asset Compute applications given their more intensive local processing and disk activity. Some applications, depending on their implementation, might also not work well with concurrent activity. The Asset Compute SDK ensures activations are separated by writing files to different unique folders.

Test applications to find the optimal numbers for `concurrency` and `memorySize`. Larger containers = higher memory limit could allow for more concurrency but could also be wasteful for lower traffic.
